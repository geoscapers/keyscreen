-- font for making scrollong text
font = {

    [" "] = {
        "     ",
        "     ",
        "     ",
        "     ",
        "     "
    },

    ["A"] = {
        "ooooo.",
        "o.  o.",
        "ooooo.",
        "o.  o.",
        "o.  o."
    },
      
    ["B"] = {
        "oooo. ",
        "o.  o.",
        "oooo. ",
        "o.  o.",
        "oooo. "
    },

    ["C"] = {
        " ooo. ",
        "o.    ",
        "o.    ",
        "o.    ",
        " ooo. "
    },

    ["D"] = {
        "oooo. ",
        "o. oo.",
        "o.  o.",
        "o. oo.",
        "oooo. "
    },

    ["E"] = {
        "ooooo",
        "o.    ",
        "oooo ",
        "o.    ",
        "ooooo"
    },

    ["F"] = {
        "ooooo",
        "o.    ",
        "oooo ",
        "o.    ",
        "o.    "
    },

    ["G"] = {
        " ooo. ",
        "o.    ",
        "o. oo.",
        "o.  o.",
        " ooo. "
    },

    ["H"] = {
        "o.  o.",
        "o.  o.",
        "ooooo.",
        "o.  o.",
        "o.  o."
    },

    ["I"] = {
        "ooo",
        " o. ",
        " o. ",
        " o. ",
        "ooo"
    },

    ["J"] = {
        "   o.",
        "   o.",
        "   o.",
        "o. o.",
        " oo. "
    },

    ["K"] = {
        "o.  o.",
        "o. o. ",
        "ooo.  ",
        "o. o. ",
        "o.  o."
    },

    ["L"] = {
        "o.  ",
        "o.  ",
        "o.  ",
        "o.  ",
        "oooo"
    },

    ["M"] = {
        "o.    o.",
        "oo.  oo.",
        "o. o. o.",
        "o.    o.",
        "o.    o."
    },

    ["N"] = {
        "o.   o.",
        "oo.  o.",
        "o o. o.",
        "o.  oo.",
        "o.   o."
    },

    ["O"] = {
        " ooo. ",
        "o.  o.",
        "o.  o.",
        "o.  o.",
        " ooo.  "
    },

    ["P"] = {
        "oooo. ",
        "o.  o.",
        "oooo. ",
        "o.    ",
        "o.    "
    },

    ["Q"] = {
        " ooo. ",
        "o.  o.",
        "o.  o.",
        "o. o. ",
        " oo o."
    },

    ["R"] = {
        "oooo. ",
        "o.  o.",
        "oooo. ",
        "o. o. ",
        "o.  o."
    },

   ["S"] = {
        " ooo. ",
        "o.    ",
        " ooo. ",
        "    o.",
        "oooo. "
    },

    ["T"] = {
        "ooooo",
        "  o. ",
        "  o. ",
        "  o. ",
        "  o. "
    },

    ["U"] = {
        "o.  o.",
        "o.  o.",
        "o.  o.",
        "o.  o.",
        " ooo. "
    },

    ["V"] = {
        "o.  o.",
        "o.  o.",
        "o.  o.",
        " o.o. ",
        "  o.  "
    },

    ["W"] = {
        "o.    o.",
        "o.    o.",
        "o. o. o.",
        "o.o.o o.",
        " o.  o. "
    },

    ["X"] = {
        "o.  o.",
        " o.o. ",
        "  o.  ",
        " o.o. ",
        "o.  o."
    },

    ["Y"] = {
        "o.  o.",
        "o.  o.",
        " o.o. ",
        "  o.  ",
        "  o.  "
    },

    ["Z"] = {
        "ooooo",
        "   o. ",
        "  o.  ",
        " o.   ",
        "ooooo"
    },

    ["Å"] = {
        " ooo. ",
        " o.o. ",
        "o.  o.",
        "ooooo.",
        "o.  o."
    },

    ["Ä"] = {
        "o.o.o.",
        " o.o. ",
        "o.  o.",
        "ooooo.",
        "o.  o."
    },

    ["Ö"] = { 
        "o.  o.",
        " ooo. ",
        "o.  o.",
        "o.  o.",
        " ooo. "
    },

    ["0"] = {
        " ooo. ",
        "o.  o.",
        "o.o o.",
        "o.  o.",
        " ooo. "
    },

    ["1"] = {
        " o.",
        "oo.",
        " o.",
        " o.",
        " o."
    },

    ["2"] = {
        " ooo. ",
        "o.  o.",
        "  oo. ",
        " o.   ",
        "ooooo"
    },

    ["3"] = {
        " ooo. ",
        "o.  o.",
        "   o. ",
        "o.  o.",
        " ooo. "
    },

    ["4"] = {
        "o.  o.",
        "o.  o.",
        "ooooo.",
        "    o.",
        "    o."
    },

    ["5"] = {
        "ooooo ",
        "o.    ",
        "oooo. ",
        "    o.",
        "oooo. "
    },

    ["6"] = {
        " ooo. ",
        "o.    ",
        "oooo. ",
        "o.  o.",
        " ooo. "
    },

    ["7"] = {
        "ooooo.",
        "    o.",
        "   o. ",
        "  o.  ",
        "  o.  "
    },

    ["8"] = {
        " ooo. ",
        "o.  o.",
        " ooo. ",
        "o.  o.",
        " ooo. "
    },

    ["9"] = {
        " ooo. ",
        "o.  o.",
        " oooo.",
        "    o.",
        " ooo. "
    },

    ["!"] = {
        "oo.",
        "oo.",
        "oo.",
        "  ",
        "oo."
    },

    ["?"] = {
        " ooo. ",
        "o.  o.",
        "  oo. ",
        "      ",
        "  o.  "
    },

    ["."] = {
        "  ",
        "  ",
        "  ",
        "  ",
        "o."
    },

    [","] = {
        "   ",
        "   ",
        "   ",
        " o.",
        "o. "
    },

    ["/"] = {
        "    o.",
        "   o. ",
        "  o.  ",
        " o.   ",
        "o.    "
    },

    ["("] = {
        " o.",
        "o. ",
        "o. ",
        "o. ",
        " o."
    },

    [")"] = {
        "o. ",
        " o.",
        " o.",
        " o.",
        "o. "
    },

    ["*"] = {
        "  o.  ",
        " ooo. ",
        "ooooo.",
        " ooo. ",
        "  o.  "
    },

    ["+"] = {
        "  o.  ",
        "  o.  ",
        "ooooo",
        "  o.  ",
        "  o.  "
    },

    ["-"] = {
        "     ",
        "     ",
        "ooooo",
        "     ",
        "     "
    },

    ["¤"] = {
        " o o ",
        " o o ",
        "     ",
        "o   o.",
        " ooo "
    },

    [":"] = {
        " ",
        "o",
        " ",
        "o",
        " "
    }
  

}

--rainbow colors, 25 of them. when given a number returns the color that is the modulo of the number
--a stands for the alpha value of the color
function rainbowColor(colorNumber, a)
    colorNumber = math.floor(colorNumber)
    
    x = colorNumber%25
    if x < 0 then
        x = x+25
    end    
    if x == 0 then
        return tocolor(0.94, 0, 0, a)
    elseif x == 1 then
        return tocolor(0.94, 0.24, 0, a)
    elseif x == 2 then
        return tocolor(0.94, 0.47, 0, a)
    elseif x == 3 then
        return tocolor(0.93, 0.59, 0, a)        
    elseif x == 4 then
        return tocolor(0.94, 0.71, 0, a)
    elseif x == 5 then
        return tocolor(0.94,0.94, 0, a)
    elseif x == 6 then
        return tocolor(0.71, 0.94, 0, a)
    elseif x == 7 then
        return tocolor(0.47, 0.94, 0, a)
    elseif x == 8 then
        return tocolor(0.24, 0.94, 0, a)
    elseif x == 9 then
        return tocolor(0, 0.94, 0, a)
    elseif x == 10 then
        return tocolor(0, 0.94, 0.24, a)
    elseif x == 11 then
        return tocolor(0, 0.94, 0.47, a)
    elseif x == 12 then
        return tocolor(0, 0.94, 0.71, a)
    elseif x == 13 then
        return tocolor(0, 0.94, 0.94, a)
    elseif x == 14 then
        return tocolor(0, 0.71, 0.94, a)
    elseif x == 15 then
        return tocolor(0, 0.47, 0.94, a)
    elseif x == 16 then
        return tocolor(0, 0.24, 0.94, a)
    elseif x == 17 then
        return tocolor(0, 0, 0.94, a)
    elseif x == 18 then
        return tocolor(0.24, 0, 0.94, a)
    elseif x == 19 then
        return tocolor(0.47, 0, 0.94, a)
    elseif x == 20 then
        return tocolor(0.71, 0, 0.94, a)
    elseif x == 21 then
        return tocolor(0.94, 0, 0.94, a)
    elseif x == 22 then
        return tocolor(0.94, 0, 0.71, a)
    elseif x == 23 then
        return tocolor(0.94, 0, 0.47, a)
    elseif x == 24 then
        return tocolor(0.94, 0, 0.24, a)
    else
        print('horror horror number is', x)
        return tocolor(1,1,1,1)
    end    
end



--part of the matrix test seing that all rows are of the same length
function helloKeygroup(keyboard, color, delay, keygroup)
    local transparent = tocolor(0, 0, 0, 0)
    while true do
        for i=1,#keygroup do
            local key = keygroup[i]
            --print("I am ", color, " walker, on key ", key)
            if key.name ~= "LOGO" then
                keyboard[key] = color
            end 
            wait(delay)
            keyboard[key] = transparent   
        end
    end
end

--matrix test testing that all rows are of equal length
function helloScanline(color, speed)
    thread(helloKeygroup, keyboard, color,  speed, keyleds.groups.row1)
    thread(helloKeygroup, keyboard, color,  speed, keyleds.groups.row2)
    thread(helloKeygroup, keyboard, color,  speed, keyleds.groups.row3)    
    thread(helloKeygroup, keyboard, color,  speed, keyleds.groups.row4)
    thread(helloKeygroup, keyboard, color,  speed, keyleds.groups.row5)
    thread(helloKeygroup, keyboard, color,  speed, keyleds.groups.row6)
end

-- keyboard matrix is of size 22x6, give coordinates and color to set pixel, keyboard is the RenderTarget used as buffer 
--x and y is wrong way, sorry
function setPixel(color, x, y, keyboard)
    if x > 0 and x <= 6 and y > 0 and y <= 22 then
        local row = keyleds.groups.row1
        if x == 1 then
            row = keyleds.groups.row1
        elseif x == 2 then
            row = keyleds.groups.row2
        elseif x == 3 then
            row = keyleds.groups.row3
        elseif x == 4 then 
            row = keyleds.groups.row4
        elseif x == 5 then
            row = keyleds.groups.row5
        elseif x == 6 then
            row = keyleds.groups.row6           
        end
        local key = row[y]
        if key.name ~= "LOGO" then              
            keyboard[key] = color
        end
    end         
end    

-- Returns color in the given coordinates, keyboard is the buffer we have drawed in, keyboard matrix is of size 22x6 
function getPixel(x, y, keyboard)
    if x > 0 and x <= 6 and y > 0 and y <= 22 then
        local row = keyleds.groups.row1
        if x == 1 then
            row = keyleds.groups.row1
        elseif x == 2 then
            row = keyleds.groups.row2
        elseif x == 3 then
            row = keyleds.groups.row3
        elseif x == 4 then 
            row = keyleds.groups.row4
        elseif x == 5 then
            row = keyleds.groups.row5
        elseif x == 6 then
            row = keyleds.groups.row6           
        end
        local key = row[y]
        --return color, even if the name would be                 
        return keyboard[key]
    end         
end 

--set the color of all the pixels used in our matrix, to color everything (also the dead keys), you can use keyboard:fill(tocolor(0, 0, 0, 0))
function setAll(color, keyboard)  
    for i=1, 6 do
        for j = 1, 22 do
            setPixel(color, i, j, keyboard)
        end    
    end       
end

--just loops trough all the pixels in our matrix, starting after a delay of startDelay and with a step of delay
function helloLoop(keyboard, color, delay, startDelay)
    local transparent = tocolor(0, 0, 0, 0)
    wait(startDelay)
    while true do
        for i=1, 6 do
            for j = 22, 1, -1 do
                setPixel(color, i, j, keyboard)
                getPixel(i, j, keyboard)
                wait(delay)
            end    
        end    
    end
end

--draws fiven letter with the given color starting from the given coordinate
function drawChar(ch, startcordinateX, keyboard, color, shadow, background)
    letter = font[ch]
    for i = 1, #letter do
        for j = 1, string.len(letter[i]) do
            pixel = string.sub(letter[i], j, j)
            if pixel == "o" then
                setPixel(color, i, j+startcordinateX, keyboard)
            elseif pixel == "." then
                setPixel(shadow, i, j+startcordinateX, keyboard)
            else
                setPixel(background, i, j+startcordinateX, keyboard)
            end
        end
        setPixel(background, i, startcordinateX+1+string.len(letter[i]), keyboard)
         setPixel(background, i, startcordinateX+1+string.len(letter[i])+1, keyboard)
    end
    return string.len(letter[1])+2        
end

--draws the given text starting from the given coordinate
function drawText(text, startcordinateX, keyboard, color, shadow, background)
    currentX = startcordinateX
    for i = 1, string.len(text) do
        if currentX < 23 then
            letter = string.sub(text, i, i)
            currentX = currentX + drawChar(letter, currentX, keyboard, color, shadow, background) 
        end
    end 
    return currentX   
end




--scrolls text forward by changing  starting coordinate
function scrollText(text, startcordinateX, keyboard, color, delay, shadow, background)
    currentx = startcordinateX
    while true do
         setAll(background, keyboard)
         endCord = drawText(text, currentx, keyboard, color, shadow, background)
         wait(delay)
         currentx = currentx -1
         if endCord < 0 then
            currentx = 23
            break
         end       
    end
end

--scrolls text forward by changing  starting coordinate, changing color like rainbow
function scrollTextRainbow(text, startcordinateX, keyboard, delay, background)
    currentx = startcordinateX
    while true do
        endcord = 0
        color = rainbowColor(currentx, 0.9)
        shadow = rainbowColor(currentx, 0.3)
        background = rainbowColor(currentx+10, 0.2)
        setAll(background, keyboard)
        endCord = drawText(text, currentx, keyboard, color, shadow, background)
        --print('the delay is ', delay)
        wait(delay)    
        currentx = currentx -1
        if endCord < 0 then
            currentx = 23
            break
        end       
    end
end

--scrolls rainbow color ower the keyboard
function rainbow(keyboard)
    colorNum = 0
    while true do       
        for j = 22, 1, -1 do
            for i=1, 6 do
                color = rainbowColor(j+colorNum, 0.9)
                --print('this is the color ', color)
                setPixel(color, i, j, keyboard)           
            end 
                       
        end  
        colorNum = 1  +colorNum
        wait(0.05) 
    end
end

function mixClamp(t, a, b)
    return 1.0 * a + clampToZeroToOne(t) * (1.0 * b - a)
end

function mix(t, a, b)
    return 1.0 * a + t * (1.0 * b - a)
end

function relPos(v, sourceStart, sourceEnd)
    d = 1.0 * sourceEnd - sourceStart
    if d == 0 then
        return 0.5
    else    
        return (v - 1.0 * sourceStart) / d
    end
end

function map(v, sourceStart, sourceEnd, targetStart, targetEnd)
    return mix(relPos(v, sourceStart, sourceEnd), targetStart, targetEnd)
end

function mapClamp(v, sourceStart, sourceEnd, targetStart, targetEnd)
    return mixClamp(relPos(v, sourceStart, sourceEnd), targetStart, targetEnd)
end

-- Takes some number as input, returns sine wave of it as output, where each 0..1 intervall of the number gets converted to one wave from 0..1
function wave(v)
    return math.sin(math.pi * 2.0 * v) * 0.5 + 0.5 
end

function rainbowWave(t, x, y, endTime)
    if (x < 25 - t*5) then 
        return -2
    end 
    
    speed = map(t, 0, endTime, 2, 4)
    return wave( t/speed + x/(55.0 + 10*speed) )
end

function plasma(t, x, y)
    return math.sin(t * 0.8 + math.sin(math.pi * x/13.1 - t/17.0)) + math.cos(math.pi * y/9.8 - t/21.0)
end


function betterPlasma(keyboard)
    --while true do
        frameTime = 0.1
        t = 0.0
        fadeInTime = 8
        simpleWaveTime = 3.0
        crossFadeTime = 8.0
        fadeOutTime = 5.0
        darknessInPlaceTime = 5 + simpleWaveTime + crossFadeTime + 8.0
        totalTime = darknessInPlaceTime + 13.0
        totalSteps = totalTime / frameTime
        for step = 0, totalSteps do
            -- Wait and update time
            wait(frameTime)
            t = t + frameTime
            
            -- Determine fade from black
            fadeOut = mapClamp(t, totalTime - fadeOutTime, totalTime, 1.0, 0.0)
            fade = mapClamp(t, 0, fadeInTime, 0.0, fadeOut)

            -- Calculate screen                                    
            for x = 22, 1, -1 do
                for y = 1, 6 do
                    -- Determine plasma intensity, mix rainbow fade and plasma
                    rainbowWaveValue = rainbowWave(t, x, y, fadeInTime + simpleWaveTime + crossFadeTime)                    
                    plasmaValue = plasma(t, x, y)                    
                    value = mapClamp(t, 
                                     fadeInTime + simpleWaveTime, 
                                     fadeInTime + simpleWaveTime + crossFadeTime, 
                                     rainbowWaveValue,
                                     plasmaValue)
                    
                    -- Darkness for better seeing plasma waves
                    darkness = mapClamp(t, fadeInTime + simpleWaveTime, darknessInPlaceTime, 1.0, value*value)                 
                    if t < simpleWaveTime + 5 and value < -1 then
                        darkness = 0.0
                    end
                
                    -- Look up color and set pixel
                    color = rainbowColor(value * 25, fade * darkness)
                    setPixel(color, y, x, keyboard)           
                end 
            end  
        end    
    --end
end



function piirraMato(matotauluX, matotauluY, colorHead, colorBody, keyboard)    
    setPixel(colorHead, matotauluY['alku'], matotauluX['alku'], keyboard)
    for i = 1, table.maxn(matotauluX) do
        setPixel(colorBody, matotauluY[i], matotauluX[i], keyboard)
    end
end

function paivitaRuoka(matotauluX, matotauluY, ruokatauluX, ruokatauluY)
    matotauluX['aika'] = matotauluX['aika']-0.15
    matotauluX['score'] = matotauluX['score']+1
    if matotauluX['aika'] <= 0.1 then
        matotauluX['aika'] = 0.1
    end
    if matotauluX['score'] < 6 then
        matotauluX['ruoka'] = ruokatauluX[table.maxn(ruokatauluX)]
        matotauluY['ruoka'] = ruokatauluY[table.maxn(ruokatauluY)]
        table.remove(ruokatauluX, table.maxn(ruokatauluX))
        table.remove(ruokatauluY, table.maxn(ruokatauluY))
    end
end


function colorScorePos(keyboard, posNum, score, x, y)
    uncompletedColor = tocolor(0.5,0.6,0.7,0.25)
    completedColor = tocolor(1,0.5,0,0.45)
    currentColor = tocolor(1,0.7,0,1)

    color = uncompletedColor 
    if score == posNum then
        color = currentColor
    elseif score > posNum then
        color = completedColor
    end        
    setPixel(color, y, x, keyboard)
end

function scorevalo(matotauluX)
    score = matotauluX['score']
    colorScorePos(keyboard, 1, score, 19, 5)
    colorScorePos(keyboard, 2, score, 20, 5)
    colorScorePos(keyboard, 3, score, 21, 5)
    colorScorePos(keyboard, 4, score, 19, 4)
    colorScorePos(keyboard, 5, score, 20, 4)
    colorScorePos(keyboard, 6, score, 21, 4)
end


function paivitaMato(keyboard, suunta, ruokatauluX, ruokatauluY )  
    matotauluX['vika'] = matotauluX[table.maxn(matotauluX)]
    matotauluY['vika'] = matotauluY[table.maxn(matotauluY)]
    for i = table.maxn(matotauluX), 2, -1 do
        matotauluX[i] = matotauluX[i-1]
        matotauluY[i] = matotauluY[i-1]
    end
    matotauluX[1] = matotauluX['alku']
    matotauluY[1] = matotauluY['alku']
    if suunta == 'u' then
        matotauluX['alku'] = matotauluX[1]
        matotauluY['alku'] = matotauluY[1]-1
    elseif suunta == 'd' then
        matotauluX['alku'] = matotauluX[1]
        matotauluY['alku'] = matotauluY[1]+1 
    elseif suunta == 'l' then
        matotauluX['alku'] = matotauluX[1]-1
        matotauluY['alku'] = matotauluY[1]   
    elseif suunta == 'r' then
        matotauluX['alku'] = matotauluX[1]+1
        matotauluY['alku'] = matotauluY[1]  
    else
        print('horror suunta was given as ', suunta)              
    end
    --print('x cord ', matotauluX['alku'] ,' == ', matotauluX['ruoka'])
    --print('y cord ', matotauluY['alku'] ,' == ', matotauluY['ruoka'])
    if (matotauluX['alku'] == matotauluX['ruoka']) then
        if (matotauluY['alku'] == matotauluY['ruoka']) then
            --print('ruoka paivittyy')
            paivitaRuoka(matotauluX, matotauluY, ruokatauluX, ruokatauluY)
            matotauluX[table.maxn(matotauluX)+1] = matotauluX['vika']
            matotauluY[table.maxn(matotauluY)+1] = matotauluY['vika']
        end
    end  
    
end

--siirtää ja piirtää ruoan
function ruokaliike(suunta, matotauluX, matotauluY, colorRuoka,keyboard)
    setPixel(tocolor(0,0,0,1), matotauluY['ruoka'], matotauluX['ruoka'], keyboard)   
    if suunta == 'u' then
        matotauluX['ruoka'] = matotauluX['ruoka']
        matotauluY['ruoka'] = matotauluY['ruoka']-1
    elseif suunta == 'd' then
        matotauluX['ruoka'] = matotauluX['ruoka']
        matotauluY['ruoka'] = matotauluY['ruoka']+1
    elseif suunta == 'l' then
        matotauluX['ruoka'] = matotauluX['ruoka']-1
        matotauluY['ruoka'] = matotauluY['ruoka']
    elseif suunta == 'r' then
        matotauluX['ruoka'] = matotauluX['ruoka']+1
        matotauluY['ruoka'] = matotauluY['ruoka']
    else
        print('horror suunta was given as ', suunta)              
    end
    setPixel(colorRuoka, matotauluY['ruoka'], matotauluX['ruoka'], keyboard)  

end

function nuolivalo(suunta, keyboard)
    setPixel(tocolor(0,0,0,1), 5, 17, keyboard)
    setPixel(tocolor(0,0,0,1), 6, 18, keyboard)
    setPixel(tocolor(0,0,0,1), 6, 17, keyboard)
    setPixel(tocolor(0,0,0,1), 6, 16, keyboard) 
    if suunta == 'u' then
        setPixel(tocolor(1,1,1,1), 5, 17, keyboard) 
    elseif suunta == 'd' then
        setPixel(tocolor(1,1,1,1), 6, 17, keyboard) 
    elseif suunta == 'l' then
        setPixel(tocolor(1,1,1,1), 6, 16, keyboard)   
    elseif suunta == 'r' then
        setPixel(tocolor(1,1,1,1), 6, 18, keyboard) 
    else
        print('horror suunta was given as ', suunta)              
    end
end


function matokierros(keyboard, matotauluX, matotauluY,ruokatauluX, ruokatauluY,  colorHead, colorBody, colorRuoka, suunta)   
    wait(matotauluX['aika']/2.0)
    nuolivalo(suunta, keyboard)
    wait(matotauluX['aika']/2.0)
    setAll(tocolor(0,0,0,1), keyboard) 
    matoreuna(keyboard)
    nuolivalo(suunta, keyboard)
    --piirra ruoka 
    setPixel(colorRuoka, matotauluY['ruoka'], matotauluX['ruoka'], keyboard)   
    paivitaMato(keyboard,suunta,ruokatauluX, ruokatauluY)
    piirraMato(matotauluX, matotauluY, colorHead, colorBody, keyboard)
    scorevalo(matotauluX)
end 

--viimeisen ruoan karkumatka, ruokatapla tarkottaa että ruoka pyrahtaa npempaa
function matokierros2(keyboard, matotauluX, matotauluY,ruokatauluX, ruokatauluY,  colorHead, colorBody, colorRuoka, suunta, ruokasuunta, ruokatupla)   
    wait(matotauluX['aika']/2.0)
    nuolivalo(suunta, keyboard)
    if ruokatupla then
        ruokaliike(ruokasuunta, matotauluX, matotauluY,colorRuoka, keyboard)
    end
    wait(matotauluX['aika']/2.0)
    setAll(tocolor(0,0,0,1), keyboard)
    matoreuna(keyboard) 
    ruokaliike(ruokasuunta, matotauluX, matotauluY,colorRuoka, keyboard)
    
    nuolivalo(suunta, keyboard) 
    paivitaMato(keyboard,suunta,ruokatauluX, ruokatauluY)
    piirraMato(matotauluX, matotauluY, colorHead, colorBody, keyboard)
    scorevalo(matotauluX)
end 

function matoreuna(keyboard)
    color = tocolor(160/255.0,82/255.0,45/255.0, 0.4)
    for i = 1, 14 do
        setPixel(color, 1, i, keyboard)  
        setPixel(color, 6, i+1, keyboard) 
    end
    for i = 1, 6 do
        setPixel(color, i, 2, keyboard)
        setPixel(color, i, 14, keyboard)
    end

end

   

function matopeli(keyboard, colorHead, colorBody, colorRuoka)
    --while true do
        matoreuna(keyboard)
        wait(0.5)
        matotauluX = {}
        matotauluX['alku'] = 7
        matotauluX[1] = 6
        matotauluX[2] = 5
        matotauluY = {}
        matotauluY['alku'] = 4
        matotauluY[1] = 4
        matotauluY[2] = 4
        matotauluX['aika'] = 0.8
        matotauluX['ruoka'] = 6
        matotauluY['ruoka'] = 2
        matotauluX['score'] = 0
        ruokatauluX = {}
        ruokatauluY = {}
        ruokatauluX[1] = 9
        ruokatauluX[2] = 3
        ruokatauluX[3] = 10 
        ruokatauluX[4] = 6
        ruokatauluX[5] = 13
        ruokatauluY[1] = 3
        ruokatauluY[2] = 2
        ruokatauluY[3] = 4
        ruokatauluY[4] = 5
        ruokatauluY[5] = 2
        piirraMato(matotauluX, matotauluY, colorHead, colorBody, keyboard)
        wait(0.25)
        for i = 0, 2 do
            matokierros(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka,'r')
        end
        for i = 0, 1 do
            matokierros(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka,'u')
        end
        for i = 0, 3 do
            matokierros(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'l')
        end
        matokierros(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'd')        
        for i = 0, 6 do
            matokierros(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'r')
        end
        matokierros(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'u')
        for i = 0, 6 do
            matokierros(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'l')
        end  
        for i = 0, 2 do
            matokierros(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'd')
        end 
        for i = 0, 3 do
            matokierros(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'r')
        end
        for i = 0, 2
         do 
            matokierros(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'u')  
        end 
        for i = 0, 6 do
            matokierros(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'l')
        end 
        matokierros(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'd')  
        for i = 0, 1 do
            matokierros(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'r')
        end 
        --matotauluX['aika'] = 0.6  
        for i = 0, 1 do
            matokierros2(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'r', 'r', false)
            matokierros(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'r')
        end 
        for i = 0, 1 do
            matokierros2(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'r', 'd', false)
        end 
        matokierros2(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'd', 'l', true)
        for i = 0, 4 do
            matokierros2(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'l', 'l', false)
        end
        matokierros2(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'l', 'u', true)
        matokierros2(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'u', 'u', true)
        matokierros2(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'u', 'r', false)
        for i = 0, 4 do
            matokierros2(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'r', 'r', false)
        end
        matokierros2(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'u', 'l', false)
        for i = 0, 1 do
            matokierros2(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'l', 'l', true)
        end
        matokierros2(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'l', 'l', false)
        matokierros2(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'l', 'd', false)
        matokierros2(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'l', 'd', false) 
        matokierros2(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'd', 'd', false) 
        for i = 0, 1 do
            matokierros2(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'd', 'r', false) 
        end
        for i = 0, 3 do
            matokierros2(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'r', 'r', false) 
        end
        matokierros2(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'r', 'u', true)
        matokierros2(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'u', 'l', false)
        matokierros2(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'u', 'l', false)
        for i = 0, 1 do
            matokierros2(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'l', 'l', false)
        end
        matokierros(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'l')
        matokierros2(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'l', 'd', false)
        matokierros2(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'd', 'r', false)
        matokierros2(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'r', 'r', false)
        matokierros2(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'r', 'r', false)
        for i = 0, 1 do
            matokierros(keyboard, matotauluX, matotauluY, ruokatauluX, ruokatauluY, colorHead, colorBody, colorRuoka, 'r')
        end
        wait(0.5)
        for i = 0, 2 do
            drawText('WIN', 1, keyboard, tocolor(1,1,1,1), tocolor(0.5,0.5,0.5,0.5), tocolor(0,0,0,0))
            wait(0.8)
            
            setAll(tocolor(0,0,0,1), keyboard)
            wait(0.2)
        end    
   -- end
end

function clampToZeroToOne(v)
    if v < 0 then
        return 0
    elseif v > 1 then    
        return 1
    else 
        return v
    end        
end

function fire(keyboard)
    --while true do
        --initialise screen sized array
        divisor = 4.6
        fireStrength = 4
        flameSmoothing = 0.6
        sparkSmoothing = 0.9
        buff = {}
        for x=1,22 do
            buff[x] = {}
            for y=1,7 do
                buff[x][y] = 0.0
            end
        end
        
        t = 0.0
        waveT = 0.0
        frameTime = 0.035
        sparkTime = 33.0
        soloSparkTime = 9.0
        coolingTime = 3.0
        totalTime = 55.0
        fireFadeTime = 15.0
        sparkStartTime = totalTime - coolingTime - sparkTime
        sparkEndTime = totalTime - coolingTime
        sparkFadeInTime = 10.0
        sparkFadeOutTime = 12.0
        totalFrames = totalTime / frameTime
        for counter = 1, totalFrames do
             

            -- Change things occasionally for more interesting        
            if (counter % 23) == 0 then
                fireStrength = fireStrength * 0.5 + 0.5 * (3.0 + math.random() * 7.0)
            end
            if (counter % 113) == 0 then
                divisor = divisor * 0.5 + 0.5 * (4.0 + math.random() * 1.5)
            end
            if (counter % 213) == 0 then
                flameSmoothing = flameSmoothing * 0.8 + 0.2 * (math.random()*0.5 + 0.5)
            end
            if (counter % 313) == 0 then
                sparkSmoothing = sparkSmoothing * 0.8 + 0.2 * (math.random()*0.5 + 0.5)
            end
            
            
            if t < sparkStartTime + fireFadeTime then
                -- Kindle low row
                for x=1,22 do
                    --buff[x][7] = buff[x][7] * 0.9 + 0.1 * math.random() * math.random()* math.random() * 7
                    fireStr = mapClamp(t, sparkStartTime, sparkStartTime + fireFadeTime, 1.0, 0.0)
                    centerPyre = (11.0 - math.abs(x - 11.0)) / 11.0
                    buff[x][6] = buff[x][6] * sparkSmoothing + (1.0 - sparkSmoothing) * (math.random() * math.random()* math.random() * fireStrength * (centerPyre * 0.2 + 0.8) * fireStr)
                end
            end
                
            if t < sparkEndTime then
                -- Kindle a moving spark
                num = math.floor(mapClamp(t, sparkStartTime, sparkEndTime - soloSparkTime, 6, 1))
                for k = 1, num do
                    strength = mapClamp(t, sparkStartTime, sparkStartTime + sparkFadeInTime, 0, 1.0)
                    strength = strength * mapClamp(t, sparkEndTime - sparkFadeOutTime, sparkEndTime - k*2.0, 1.0, 0.0)
                    
                    sparkSlowDown = mapClamp(t, totalTime - soloSparkTime - 5, totalTime, 1.0, 0.1)
                    
                    xw1 = wave(waveT/(3.3 + k * 0.1   ) + k * 0.121)
                    xw2 = wave(waveT/(7.3 + k * 0.16  ) + k * 0.621 + 0.21)
                    yw1 = wave(waveT/(0.9 + k * 0.13  ) + k * 0.134 + 0.5)
                    yw2 = wave(waveT/(4.5 + k * 0.23  ) + k * 0.234 + 0.75)
                    
                    xPos = math.floor(mixClamp((xw1 + xw2)/2, 3, 20))
                    yPos = math.floor(mixClamp((yw1 + yw2)/2, 2, 6))
                    value = mix(math.random(), 0.8, 3.0)
                    buff[xPos][yPos] = buff[xPos][yPos] * (1.0 - strength) + (strength) * value
                end
            end            
            
            for x=2,21 do
                for y=5,1,-1 do
                    y2 = 2
                    if y==5 then 
                        y2 = 1
                    end
                    newValue = (buff[x-1][y+1] * 0.75 + buff[x][y+1] * 1.5 + buff[x+1][y+1] * 0.75 + buff[x][y+y2] * 1) / divisor
                    buff[x][y] = flameSmoothing * buff[x][y] + (1.0 - flameSmoothing) * newValue
                end
            end

            for x=1,22 do
                for y=1,5 do
                    heat = buff[x][y] * 2.6 - 1.1    
                    r = clampToZeroToOne(heat * 2)
                    g = clampToZeroToOne(heat * 2 - 0.8) * 0.6
                    b = clampToZeroToOne(heat * 4 - 3) * 0.1
                
                    color = tocolor(r, g, b, 1.0)
                    setPixel(color, y, x, keyboard)                 
                end
                stoneFade = mapClamp(t, totalTime-sparkTime, totalTime - soloSparkTime, 1.0, 0.0)
                setPixel(tocolor(0.3*stoneFade, 0.25*stoneFade, 0.2*stoneFade, 1.0), 6, x, keyboard)                 
            end
            
            -- Delay and increase t
            wait(frameTime)
            t = t + frameTime
            
            sparkSlowDown = mapClamp(t, totalTime - soloSparkTime - 10.0, totalTime, 1.0, 0.01)
            waveT = waveT + frameTime * sparkSlowDown
        end
    --end
end



function water(keyboard)
--    while true do
        --initialise screen sized array
        buff = {}
        for x=1,22 do
            buff[x] = {}
            for y=1,6 do
                buff[x][y] = 0.0
            end
        end

        particleCount = 150
        particleX = {}
        particleY = {}        
        particleXVel = {}
        particleYVel = {}        
        particleStr = {}        
        for i = 1, particleCount do
            particleX[i] = 0.0
            particleY[i] = 0.0    
            particleXVel[i] = 0.0
            particleYVel[i] = 0.0    
            particleStr[i] = 0.0
        end

        particleToSpawn = 1
        spawnCountdown = 0
        spawnCountdownMax = 3
        
        smudge = 0.92
        
        t = 0.0
        frameTime = 0.03
        fadeInTime = 10.0
        totalTime = 30.0
        fadeOutTime = 7.0
        totalFrames = totalTime / frameTime
        for counter = 1, totalFrames do
            
            smudge = mapClamp(t, 0.3*totalTime, 0.4*totalTime, 0.925, 0.955)
            smudge = mapClamp(t, 0.45*totalTime, 0.65*totalTime, smudge, 0.91)
            
            -- Clear buffer
            for x=1,22 do
                for y=1,6 do
                    buff[x][y] = buff[x][y] * smudge
                end
            end

            -- Fill buffer from particles
            for i = 1, particleCount do
                x = math.floor(particleX[i] + 0.5)
                y = math.floor(particleY[i] + 0.5)
                if x >= 1 and y >= 1 and x <= 22 and y <= 6 then
                    buff[x][y] = particleStr[i] + buff[x][y]
                end
            end

            -- Draw buffer
            for x=1,22 do
                for y=1,6 do
                    -- Map mass to color
                    mass = buff[x][y]
                    r = 0
                    g = 0
                    b = 0
                    if (mass < 1.0) then
                        r = mapClamp(mass, 0.5, 1, 0, 0.5)
                        g = mapClamp(mass, 0.3, 1, 0, 0.6)
                        b = mapClamp(mass, 0.0, 0.6, 0, 0.85)
                    else    
                        r = mapClamp(mass, 1, 4, 0.5, 1)
                        g = mapClamp(mass, 1, 2.5, 0.6, 1)
                        b = mapClamp(mass, 1, 1.5, 0.85, 1)
                    end
                    color = tocolor(r, g, b, 0.9)
                    setPixel(color, y, x, keyboard)                 
                end
            end

            -- Spawn particles
            for p = 1, 5 do
                spawnSpeed = mapClamp(t, 0, totalTime * 0.3, 0.6, 1.5)
                spawnPosX = (map(wave(t/5) + wave(t/13), 0, 2, -0.15, 1.15)) * 22
                spawnPosY = (map(wave(t/7) + wave(t/17), 0, 2, 0.25, 1.15)) * 6
                spawnVelX = spawnSpeed * (math.random() - 0.5)
                spawnVelY = spawnSpeed * (math.random() - 0.5)
                spawnStr = mapClamp(t, 0, fadeInTime, 0, math.random())
                spawnStr = mapClamp(t, totalTime - fadeOutTime, totalTime, spawnStr, 0)

                -- Another particle spawner position too
                if t > 0.3*totalTime and (particleToSpawn % 2) == 0 then
                    spawnPosX = (map(wave(t/7.2 + 0.7) + wave(t/18.32 + 0.5), 0, 2, 0, 1)) * 22
                    spawnPosY = (map(wave(t/9.2 + 0.2) + wave(t/15.23 + 0.3), 0, 2, 0.35, 1)) * 6
                end
                
                spawnCountdown = spawnCountdown - 1
                if spawnCountdown <= 0 then
                    particleX[particleToSpawn] = spawnPosX
                    particleY[particleToSpawn] = spawnPosY
                    particleXVel[particleToSpawn] = spawnVelX
                    particleYVel[particleToSpawn] = spawnVelY
                    particleStr[particleToSpawn] = spawnStr
                    
                    spawnCountdown = spawnCountdownMax
                    particleToSpawn = (particleToSpawn + 1) % particleCount
                end 
            end

            -- Forces
            forceX = mapClamp(t, totalTime * 0.6, totalTime * 0.9, 0, 0.21*(wave(t/8)-0.5))
            forceY = mapClamp(t, 0, totalTime * 0.8, 0.12, 0.03)

            -- Simulate
            for i = 1, particleCount do
                particleXVel[i] = particleXVel[i] + forceX
                particleYVel[i] = particleYVel[i] + forceY
                particleX[i] = particleX[i] + particleXVel[i]
                particleY[i] = particleY[i] + particleYVel[i]
                particleStr[i] = particleStr[i] * 0.98
            end
            
            -- Delay and increase t
            wait(frameTime)
            t = t + frameTime
        end
--    end
end





function helloAssembly(keyboard)
    wordcordX = {}
    wordcordY = {}
    wordcordX[1] = 7
    wordcordY[1] = 3
    wordcordX[2] = 8
    wordcordY[2] = 3
    wordcordX[3] = 9
    wordcordY[3] = 3
    wordcordX[4] = 10
    wordcordY[4] = 3  
    wordcordX[5] = 11
    wordcordY[5] = 3 
    wordcordX[6] = 5
    wordcordY[6] = 4   
    wordcordX[7] = 6
    wordcordY[7] = 4 
    wordcordX[8] = 7
    wordcordY[8] = 4 
    wordcordX[9] = 8
    wordcordY[9] = 4 
    wordcordX[10] = 9
    wordcordY[10] = 4 
    wordcordX[11] = 10
    wordcordY[11] = 4 
    wordcordX[12] = 11
    wordcordY[12] = 4 
    wordcordX[13] = 12
    wordcordY[13] = 4 
    wordcordX[14] = 7
    wordcordY[14] = 5 
    wordcordX[15] = 8
    wordcordY[15] = 5 
    wordcordX[16] = 9
    wordcordY[16] = 5 
    wordcordX[17] = 10
    wordcordY[17] = 5 
    waitTime = 0.05  
    for i = 1, table.maxn(wordcordX) do       
        for a = 0, 1, 0.1 do           
            setPixel(tocolor(a, 1, a, a*0.85),wordcordY[i] , wordcordX[i], keyboard)                 
            wait(waitTime)
        end
        if i == 5 then
            wait(0.5)
            waitTime = 0.03
        elseif i == 13 then
            wait(0.25)
            waitTime = 0.02
        end       
    end
    wait(1)
    for j = 1, 0, -0.05 do
        for i = 1, table.maxn(wordcordX) do
            setPixel(tocolor(j, j, 1, j),wordcordY[i] , wordcordX[i], keyboard)                                   
        end 
        wait(0.05)  
    end
end

function demo()
    dark = tocolor(0, 0.5, 0.2, 0.7)
    light = tocolor(0.6, 1, 0.2, 1)
    background = tocolor(0, 0, 0.3, 0.5)

    wait(3)

    helloAssembly(keyboard)
    betterPlasma(keyboard)
    
    scrollText( "KEYSCREEN", 23, keyboard, tocolor(1,0.9,0.8,1), 0.15, tocolor(1,0.9,0.8,0.22), tocolor(0,0,0,0.1))
    scrollText( "BY GEOSCAPERS", 23, keyboard, tocolor(1,0.8,0.6,0.8), 0.12, tocolor(1,0.8,0.6,0.2), tocolor(0,0,0,0.1))

    water(keyboard)
    

--    scrollText( "YOU HAVE ALL", 23, keyboard, tocolor(0.6, 1, 0.2, 1), 0.12, dark, tocolor(0,0,0,0.1))
--    scrollText( "PLAYED GAMES", 23, keyboard, tocolor(0.4, 0.6, 0.5, 1), 0.10, tocolor(0, 0.3, 0.3, 0.5), tocolor(0,0.2,0.1,0.3))
--    scrollText( "WITH A KEYBOARD,", 23, keyboard, tocolor(0.3, 0.6, 0.8, 1), 0.07, tocolor(0, 0.2, 0.4, 0.5), tocolor(0, 0.1, 0.3, 0.4))
--    scrollText( "BUT HAVE YOU PLAYED ON A KEYBOARD?", 23, keyboard, tocolor(0.2, 0.6, 1, 1), 0.07, tocolor(0, 0.2, 0.5, 0.5), tocolor(0, 0, 0.3, 0.5))

    scrollText( "YOU HAVE ALL PLAYED GAMES WITH A KEYBOARD", 23, keyboard, tocolor(0.3, 0.6, 0.8, 1), 0.065, tocolor(0.05, 0.2, 0.4, 0.33), tocolor(0,0.1,0.3,0.15))
    scrollText( "BUT HAVE YOU PLAYED ON A KEYBOARD?", 23, keyboard, tocolor(0.2, 0.6, 1, 1), 0.07, tocolor(0, 0.2, 0.5, 0.33), tocolor(0, 0, 0.3, 0.17))

    
    matopeli( keyboard, light, dark, tocolor(1, 0.1, 0.3,1))
    scrollTextRainbow("BY: SHIERA AND FRACTALPIXEL", 23, keyboard, 0.09, background)
    scrollTextRainbow("GREETINGS TO EVERYONE OUT THERE!", 23, keyboard, 0.06, background)
--    scrollTextRainbow("IRAH, SIERRAFOX, WAFFLE, RUSTBLOOM, ", 23, keyboard, 0.04, background)
--    scrollTextRainbow("EVERYONE OUT THERE", 23, keyboard, 0.05, background)
    fire(keyboard)
end



dark = tocolor(0, 0.5, 0.2, 0.7)
light = tocolor(0.6, 1, 0.2, 1)

background = tocolor(0, 0, 0, 0)



keyboard = RenderTarget:new()
keyboard:fill(tocolor(0,0,0,1))
setAll(background, keyboard)
--thread(scrollText, "ABCDEFGHIJKLMNOPQRSTUVWXYZ 123456789 !?/().:,", 23, keyboard, light, 0.2, dark, background)
--thread(scrollTextRainbow, "HELLO WORLD THIS IS A FINE DAY, NOW IT IS TIME FOR BREAKFAST", 23, keyboard, 0.15, background)
--thread(rainbow, keyboard)
--thread(rainbowPlasma,keyboard)
--thread(matopeli, keyboard, light, dark, tocolor(1, 0.1, 0.3,1))
--thread(fire, keyboard)
--thread(water, keyboard)
thread(demo, keyboard)
-- thread(betterPlasma, keyboard)




--testing looping trough all
--thread(helloLoop, keyboard, light,  0.1, 0)
--thread(helloLoop, keyboard, dark,  0.1, 1)

--helloScanline(dark, 0.5)
--helloScanline(light, 0.5)







--function that the RenderTarget used as buffer needs to actually render
function render(ms, target) target:blend(keyboard) end





